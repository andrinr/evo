//! Organism action execution system.
//!
//! Handles execution of all organism actions including movement, rotation,
//! attacking, energy sharing, and food consumption.

use ndarray::Array1;

use super::events::SimulationEvent;
use super::food::Food;
use super::organism::Organism;
use super::params::Params;

/// Result of executing actions - a list of events to be processed.
pub type ActionResult = Vec<SimulationEvent>;

/// Executes movement action for an organism.
///
/// # Arguments
///
/// * `entity` - The organism to move
/// * `velocity` - Movement velocity from brain output
/// * `params` - Simulation parameters
/// * `dt` - Time delta
///
/// # Returns
///
/// Empty vector (no events generated by movement).
pub fn execute_movement(
    entity: &mut Organism,
    velocity: f32,
    params: &Params,
    dt: f32,
) -> ActionResult {
    let vel_vector = Array1::from_vec(vec![
        velocity * entity.rot.cos(),
        velocity * entity.rot.sin(),
    ]) * params.move_multiplier;

    entity.pos += &(&vel_vector * dt);
    entity.consume_energy(velocity.abs() * dt * params.move_energy_rate);

    vec![]
}

/// Executes rotation action for an organism.
///
/// # Arguments
///
/// * `entity` - The organism to rotate
/// * `rotation` - Rotation amount from brain output
/// * `params` - Simulation parameters
/// * `dt` - Time delta
///
/// # Returns
///
/// Empty vector (no events generated by rotation).
pub fn execute_rotation(
    entity: &mut Organism,
    rotation: f32,
    params: &Params,
    dt: f32,
) -> ActionResult {
    entity.rot += rotation * dt * 10.0;
    entity.consume_energy(rotation.abs() * dt * params.rot_energy_rate);

    vec![]
}

/// Executes attack action (projectile shooting).
///
/// # Arguments
///
/// * `entity` - The organism attacking
/// * `attack_strength` - Attack strength from brain output
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Vector containing `ProjectileCreated` event if attack was executed.
pub fn execute_attack(
    entity: &mut Organism,
    attack_strength: f32,
    params: &Params,
) -> ActionResult {
    if attack_strength > 0.1
        && entity.energy > attack_strength * params.attack_cost_rate
        && entity.can_attack()
    {
        entity.consume_energy(attack_strength * params.attack_cost_rate);
        entity.reset_attack_cooldown(params.attack_cooldown);

        vec![SimulationEvent::ProjectileCreated {
            pos: entity.pos.clone(),
            rotation: entity.rot,
            damage: attack_strength * params.attack_damage_rate,
            owner_id: entity.id,
        }]
    } else {
        vec![]
    }
}

/// Finds the nearest organism within sharing radius.
///
/// # Arguments
///
/// * `entity` - The organism looking to share
/// * `neighbors` - List of nearby organism indices
/// * `organisms` - All organisms in the ecosystem
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Optional organism ID of the nearest target.
fn find_share_target(
    entity: &Organism,
    neighbors: &[(f32, usize)],
    organisms: &[Organism],
    params: &Params,
) -> Option<usize> {
    let mut nearest_dist = f32::MAX;
    let mut nearest_id = None;

    for (_, neighbor_id) in neighbors {
        let other = &organisms[*neighbor_id];
        if other.id != entity.id {
            let dist = (&entity.pos - &other.pos).mapv(f32::abs).sum();
            if dist < params.share_radius && dist < nearest_dist {
                nearest_dist = dist;
                nearest_id = Some(other.id);
            }
        }
    }

    nearest_id
}

/// Executes energy sharing action.
///
/// # Arguments
///
/// * `entity` - The organism sharing energy
/// * `share_amount` - Amount to share from brain output
/// * `neighbors` - List of nearby organism indices
/// * `organisms` - All organisms in the ecosystem
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Vector containing `EnergyShared` event if sharing occurred.
pub fn execute_energy_sharing(
    entity: &Organism,
    share_amount: f32,
    neighbors: &[(f32, usize)],
    organisms: &[Organism],
    params: &Params,
) -> ActionResult {
    if share_amount > 0.1 && entity.energy > 0.2 {
        if let Some(receiver_id) = find_share_target(entity, neighbors, organisms, params) {
            vec![SimulationEvent::EnergyShared {
                giver_id: entity.id,
                receiver_id,
                amount: share_amount,
            }]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

/// Executes food consumption for all nearby food items.
///
/// # Arguments
///
/// * `entity` - The organism consuming food
/// * `neighbor_foods` - List of nearby food indices
/// * `food_items` - All food in the ecosystem
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Vector of `FoodConsumed` events for each food item consumed.
pub fn execute_food_consumption(
    entity: &mut Organism,
    neighbor_foods: &[(f32, usize)],
    food_items: &[Food],
    params: &Params,
) -> ActionResult {
    let mut events = vec![];

    for (_, food_id) in neighbor_foods {
        let food_item = &food_items[*food_id];
        let org_food_dist = (&entity.pos - &food_item.pos).mapv(f32::abs).sum();

        if org_food_dist < params.body_radius * 2.0 && !food_item.is_consumed() {
            entity.gain_energy(food_item.energy, params.max_energy);
            entity.score += 1;

            events.push(SimulationEvent::FoodConsumed {
                organism_id: entity.id,
                food_id: *food_id,
            });
        }
    }

    events
}

/// Finds the nearest organism within reproduction radius for sexual reproduction.
///
/// # Arguments
///
/// * `entity` - The organism looking to reproduce
/// * `neighbors` - List of nearby organism indices
/// * `organisms` - All organisms in the ecosystem
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Optional organism ID of the nearest potential mate.
fn find_reproduction_partner(
    entity: &Organism,
    neighbors: &[(f32, usize)],
    organisms: &[Organism],
    params: &Params,
) -> Option<usize> {
    let mut nearest_dist = f32::MAX;
    let mut nearest_id = None;

    for (_, neighbor_id) in neighbors {
        let other = &organisms[*neighbor_id];
        // Only allow reproduction within same genetic pool
        if other.id != entity.id && other.energy > 0.5 && other.pool_id == entity.pool_id {
            let dist = (&entity.pos - &other.pos).mapv(f32::abs).sum();
            if dist < params.reproduction_radius && dist < nearest_dist {
                nearest_dist = dist;
                nearest_id = Some(other.id);
            }
        }
    }

    nearest_id
}

/// Executes asexual reproduction action.
///
/// # Arguments
///
/// * `entity` - The organism reproducing
/// * `energy_contribution` - Amount of energy to give to offspring (min 0.5)
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Vector containing `AsexualReproduction` event if reproduction occurred.
pub fn execute_asexual_reproduction(
    entity: &Organism,
    energy_contribution: f32,
    _params: &Params,
) -> ActionResult {
    // Must give at least 0.5 energy and have enough energy
    if energy_contribution >= 0.5 && entity.energy >= energy_contribution + 0.5 {
        vec![SimulationEvent::AsexualReproduction {
            parent_id: entity.id,
            parent_pos: entity.pos.clone(),
            energy_contribution,
        }]
    } else {
        vec![]
    }
}

/// Executes sexual reproduction action.
///
/// # Arguments
///
/// * `entity` - The organism wanting to reproduce
/// * `energy_contribution` - Amount of energy this organism wants to contribute
/// * `neighbors` - List of nearby organism indices
/// * `organisms` - All organisms in the ecosystem
/// * `params` - Simulation parameters
///
/// # Returns
///
/// Vector containing `SexualReproductionIntent` event if organism wants to reproduce.
pub fn execute_sexual_reproduction(
    entity: &Organism,
    energy_contribution: f32,
    neighbors: &[(f32, usize)],
    organisms: &[Organism],
    params: &Params,
) -> ActionResult {
    // Must have at least minimum energy and want to contribute something
    if energy_contribution > 0.0 && entity.energy >= energy_contribution + 0.5 {
        if let Some(partner_id) = find_reproduction_partner(entity, neighbors, organisms, params) {
            vec![SimulationEvent::SexualReproductionIntent {
                organism_id: entity.id,
                partner_id,
                energy_contribution,
                pos: entity.pos.clone(),
            }]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

/// Executes all actions extracted from brain output.
///
/// # Arguments
///
/// * `entity` - The organism executing actions
/// * `brain_outputs` - Neural network outputs
/// * `neighbors_orgs` - Nearby organisms for energy sharing
/// * `neighbor_foods` - Nearby food for consumption
/// * `organisms` - All organisms (for energy sharing target lookup)
/// * `food_items` - All food items
/// * `params` - Simulation parameters
/// * `dt` - Time delta
///
/// # Returns
///
/// Combined vector of all events from all executed actions.
pub fn execute_all_actions(
    entity: &mut Organism,
    brain_outputs: &Array1<f32>,
    neighbors_orgs: &[(f32, usize)],
    neighbor_foods: &[(f32, usize)],
    organisms: &[Organism],
    food_items: &[Food],
    params: &Params,
    dt: f32,
) -> ActionResult {
    let offset = params.signal_size + params.memory_size;
    let rotation = brain_outputs[offset];
    let velocity = brain_outputs[offset + 1];
    let attack_strength = brain_outputs[offset + 2];
    let share_amount = brain_outputs[offset + 3];
    let _asexual_reproduction_energy = brain_outputs[offset + 4]; // Unused - reproduction disabled
    let _sexual_reproduction_energy = brain_outputs[offset + 5]; // Unused - reproduction disabled

    let mut events = vec![];

    // Execute all actions
    events.extend(execute_rotation(entity, rotation, params, dt));
    events.extend(execute_movement(entity, velocity, params, dt));
    events.extend(execute_attack(entity, attack_strength, params));
    events.extend(execute_energy_sharing(
        entity,
        share_amount,
        neighbors_orgs,
        organisms,
        params,
    ));
    events.extend(execute_food_consumption(
        entity,
        neighbor_foods,
        food_items,
        params,
    ));

    // Reproduction actions - DISABLED (organism-initiated reproduction is turned off)
    // All reproduction now happens automatically via ecosystem.spawn()
    // If both outputs are high, asexual takes priority
    // if asexual_reproduction_energy >= 0.5 {
    //     events.extend(execute_asexual_reproduction(
    //         entity,
    //         asexual_reproduction_energy,
    //         params,
    //     ));
    // } else if sexual_reproduction_energy > 0.0 {
    //     events.extend(execute_sexual_reproduction(
    //         entity,
    //         sexual_reproduction_energy,
    //         neighbors_orgs,
    //         organisms,
    //         params,
    //     ));
    // }

    events
}
